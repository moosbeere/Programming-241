#include <iostream> // Библиотека ввода-вывода

// 1. Функция вычисления суммы через указатели (константные, чтобы не менять данные)
int sumArray(const int* begin, const int* end) {
    int sum = 0; // Переменная для накопления суммы
    // Цикл: пока текущий указатель ptr не дошел до адреса за концом массива (end)
    for (const int* ptr = begin; ptr != end; ++ptr) {
        sum += *ptr; // Разыменовываем указатель (берем значение) и прибавляем к сумме
    }
    return sum; // Возвращаем итоговую сумму
}

// 3. Простая функция для сложения
int add(int a, int b) {
    return a + b;
}

// Простая функция для вычитания
int subtract(int a, int b) {
    return a - b;
}

// 4-5. Определение типа OpFunc как указателя на функцию, принимающую два int и возвращающую int
typedef int (*OpFunc)(int, int);

// Функция, которая возвращает адрес нужной функции в зависимости от символа
OpFunc chooseOp(char op) {
    if (op == '+') return &add; // Возвращаем адрес функции сложения
    if (op == '-') return &subtract; // Возвращаем адрес функции вычитания
    return nullptr; // Если символ не опознан, возвращаем "пустой" указатель
}

int main() {
    setlocale(LC_ALL, "Russian"); // Поддержка русского языка в консоли

    // 2. Проверка функции суммы массива
    int arr[] = { 1, 2, 3, 4, 5 }; // Инициализация массива
    int sz = sizeof(arr) / sizeof(arr[0]); // Вычисление количества элементов
    // Передаем адрес начала массива и адрес сразу за его концом
    int sumptr = sumArray(arr, arr + sz);
    std::cout << "Сумма элементов массива: " << sumptr << std::endl;

    // 6. Проверка выбора функции и вызова по указателю
    char op = '+'; // Тестовый оператор
    OpFunc funcPtr = chooseOp(op); // Получаем указатель на нужную функцию
    if (funcPtr) { // Проверяем, что указатель не нулевой
        int result = funcPtr(10, 4); // Вызываем функцию через указатель
        std::cout << "Результат функции для '" << op << "': " << result << std::endl;
    }
    else {
        std::cout << "Некорректный оператор!" << std::endl;
    }

    // 7. Работа с динамической памятью
    // Выделяем память под float в "куче" и записываем туда 3.14
    float* pFloat = new float(3.14f);
    std::cout << "Значение динамического float: " << *pFloat << std::endl; // Вывод через разыменование
    delete pFloat; // Обязательное освобождение памяти, чтобы не было утечки

    return 0; // Завершение программы
}