#include <iostream>                   // Для ввода-вывода (cout, endl)
#include <queue>                      // Для использования очереди (queue)
#include <unordered_map>              // Для использования хеш-таблиц (unordered_map)
#include <vector>                     // Для использования динамических массивов (vector)
#include <string>                     // Для работы со строками string

// Алгоритм поиска в ширину (BFS) работает по принципу: сначала исследуются все соседние вершины, прежде чем переходить к вершинам следующего уровня 

int main() {
    // Создаем граф лабиринта в виде списка смежности
    // Каждая комната (вершина) связана с другими комнатами (соседями)
    std::unordered_map<std::string, std::vector<std::string>> graph;
    
    // Заполняем граф связями между комнатами на основе описания лабиринта
    // Комната S соединена с комнатами A и B
    graph["S"] = {"A", "B"};                                 // S связан с A и B
    // Комната A соединена с комнатами S и E
    graph["A"] = {"S", "E"};                                 // A связан с S и E  
    // Комната B соединена с комнатами S, C и D
    graph["B"] = {"S", "C", "D"};                           // B связан с S, C, D
    // Комната C соединена с комнатами B и J
    graph["C"] = {"B", "J"};                                // C связан с B и J
    // Комната D соединена с комнатами B и F
    graph["D"] = {"B", "F"};                                // D связан с B и F
    // Комната E соединена с комнатами A и F
    graph["E"] = {"A", "F"};                                // E связан с A и F
    // Комната F соединена с комнатами D, E и L
    graph["F"] = {"D", "E", "L"};                           // F связан с D, E, L
    // Комната L соединена с комнатами F и T
    graph["L"] = {"F", "T"};                                // L связан с F и T
    // Комната T соединена с комнатами L и H
    graph["T"] = {"L", "H"};                                // T связан с L и H
    // Комната H соединена с комнатами T и I
    graph["H"] = {"T", "I"};                                // H связан с T и I
    // Комната J соединена с комнатами C и I
    graph["J"] = {"C", "I"};                                // J связан с C и I
    // Комната I соединена с комнатами H и J (целевая комната)
    graph["I"] = {"H", "J"};                                // I связан с H и J

    // Очередь для BFS - хранит комнаты для обработки
    std::queue<std::string> searchQueue;                    // Создаем очередь для BFS
    // Начинаем поиск с комнаты S
    searchQueue.push("S");                                  // Добавляем стартовую комнату S в очередь

    // Хеш-таблица для отслеживания посещенных комнат и их предшественников
    // Ключ - комната, значение - комната, из которой мы пришли в эту комнату
    std::unordered_map<std::string, std::string> cameFrom;  // Создаем хеш-таблицу для отслеживания пути
    // Инициализируем для стартовой комнаты
    cameFrom["S"] = "";                                     // У стартовой комнаты нет предшественника

    // Пока очередь не пуста, продолжаем поиск
    while (!searchQueue.empty()) {                         // Пока есть комнаты для обработки
        // Извлекаем текущую комнату из начала очереди
        std::string currentRoom = searchQueue.front();     // Берем первую комнату из очереди
        searchQueue.pop();                                 // Удаляем ее из очереди

        // Если достигли целевой комнаты I, завершаем поиск
        if (currentRoom == "I") {                          // Проверяем, не достигли ли мы цели
            break;                                         // Выходим из цикла если нашли выход
        }

        // Получаем список соседних комнат для текущей комнаты
        std::vector<std::string> neighbors = graph[currentRoom]; // Получаем всех соседей текущей комнаты
        
        // Обрабатываем всех соседей текущей комнаты
        for (const std::string& neighbor : neighbors) {    // Перебираем всех соседей
            // Если соседняя комната еще не посещена
            if (cameFrom.find(neighbor) == cameFrom.end()) { // Проверяем, не посещали ли уже эту комнату
                // Добавляем соседа в очередь для дальнейшего исследования
                searchQueue.push(neighbor);                // Добавляем соседа в конец очереди
                // Запоминаем, откуда мы пришли в эту комнату
                cameFrom[neighbor] = currentRoom;          // Записываем откуда пришли в эту комнату
            }
        }
    }

    // Восстанавливаем путь от целевой комнаты I к стартовой комнате S
    std::vector<std::string> path;                         // Создаем вектор для хранения пути
    std::string current = "I";                             // Начинаем с конечной комнаты I
    
    // Проходим по цепочке предшественников от I до S
    while (current != "S") {                               // Пока не дойдем до стартовой комнаты
        // Добавляем текущую комнату в путь
        path.push_back(current);                           // Добавляем текущую комнату в путь
        // Переходим к предыдущей комнате в цепочке
        current = cameFrom[current];                       // Переходим к комнате из которой пришли
    }
    // Добавляем стартовую комнату
    path.push_back("S");                                   // Добавляем стартовую комнату S

    // Выводим путь в правильном порядке (от S до I)
    std::cout << "Кратчайший путь: ";                     // Выводим заголовок
    for (int i = path.size() - 1; i >= 0; --i) {          // Идем по пути в обратном порядке (от S к I)
        std::cout << path[i];                             // Выводим название комнаты
        if (i > 0) {                                      // Если это не последняя комната
            std::cout << " -> ";                          // Выводим стрелочку
        }
    }
    std::cout << std::endl;                               // Переходим на новую строку

    // Выводим длину пути
    std::cout << "Длина пути: " << path.size() - 1 << std::endl; // Вычисляем и выводим длину пути

    return 0;                                             // Завершаем программу
}
