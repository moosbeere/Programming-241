#include <iostream>

using namespace std;

// 1. Функция, которая принимает 2 указателя (на начало и "за конец" массива)
// и возвращает сумму всех элементов в этом диапазоне [begin, end)
int sum_between(const int* begin, const int* end)
{
    int sum = 0;
    const int* p = begin;

    while (p != end)
    {
        sum += *p;
        ++p;
    }

    return sum;
}

// 3. Две функции, возвращающие сумму и разность двух целых чисел
int add(int a, int b)
{
    return a + b;
}

int sub(int a, int b)
{
    return a - b;
}

// 4–5. Функция, принимающая char и возвращающая указатель на функцию
//      сложения или вычитания
using OperationPtr = int(*)(int, int);

OperationPtr choose_operation(char op)
{
    if (op == '+')
        return &add;
    if (op == '-')
        return &sub;

    return nullptr; // если символ не '+' и не '-'
}

int main()
{
    // 1. Создайте переменную со значением на Ваше усмотрение.
    int value = 10;
    cout << "1) Исходное значение переменной value: " << value << endl;

    // 2. Объявите указатель на созданную переменную.
    int* pValue = &value;

    // 3. Выведите в консоль адрес указателя и значение, которое хранится по этому адресу.
    cout << "2-3) Адрес, хранящийся в pValue: " << pValue << endl;
    cout << "     Значение по адресу pValue (*pValue): " << *pValue << endl;

    // 4. Измените значение, которое хранится по адресу указателя.
    *pValue = 25;

    // 5. Убедитесь, что переменная из 1-го пункта так же изменила своё значение.
    cout << "4-5) Новое значение по адресу pValue: " << *pValue << endl;
    cout << "     Новое значение переменной value: " << value << endl;

    // 6. Создайте массив из нескольких элементов (тип и значение на Ваше усмотрение).
    int arr[5] = { 2, 4, 6, 8, 10 };

    // 7. Выведите все элементы массива в консоль, используя указатель.
    cout << "6-7) Элементы массива через указатель: ";
    int* pArr = arr; // указывает на первый элемент массива
    for (int i = 0; i < 5; ++i)
    {
        cout << *(pArr + i) << " ";
    }
    cout << endl;

    // 8. Объявите целую переменную со значением 5.
    int number = 5;
    cout << "8) Исходное значение переменной number: " << number << endl;

    // 9. Создайте такой указатель на эту переменную, чтобы нельзя было менять адрес,
    //    на который он ссылается, но при этом, чтобы через него можно было менять значение.
    int* const pNumber = &number; // константный указатель на переменную int

    // Можно менять значение через указатель:
    *pNumber = 15;

    // 10. Убедитесь, что всё сделано правильно:
    // Попытка изменить адрес (раскомментируйте строку ниже -> будет ошибка компиляции):
    // int other = 100;
    // pNumber = &other; // ОШИБКА: присваивание к read-only переменной 'pNumber'

    // А значение через указатель успешно изменилось:
    cout << "9-10) Новое значение через pNumber (*pNumber): " << *pNumber << endl;
    cout << "       Новое значение переменной number: " << number << endl;


    // --- ЗАДАНИЯ 11–18 (вторая часть) ---

    // 11–12. Проверяем функцию sum_between на массиве целых чисел
    int data[6] = { 1, 3, 5, 7, 9, 11 };
    int total = sum_between(data, data + 6); // от первого до "за последним"
    cout << "\nЗадания 11-18:" << endl;
    cout << "11-12) Сумма элементов массива {1, 3, 5, 7, 9, 11} = " << total << endl;

    // 13–16. Работа с функциями суммы, разности и указателем на функцию
    int x = 20;
    int y = 7;

    char opChar = '+'; // поменяйте на '-' для проверки разности
    OperationPtr opPtr = choose_operation(opChar);

    if (opPtr != nullptr)
    {
        int result = opPtr(x, y); // вызов выбранной функции по указателю
        cout << "13-16) Операция '" << opChar << "' над " << x << " и " << y
             << " даёт результат: " << result << endl;
    }
    else
    {
        cout << "13-16) Некорректный символ операции: '" << opChar << "'" << endl;
    }

    // 17–18. Создаём динамический указатель типа float, выводим и удаляем
    float* pFloat = new float(3.14f); // динамическое выделение памяти под одно число
    cout << "17-18) Динамический float по адресу " << pFloat
         << " имеет значение: " << *pFloat << endl;

    delete pFloat;      // освобождаем память
    pFloat = nullptr;   // обнуляем указатель

    return 0;
}

