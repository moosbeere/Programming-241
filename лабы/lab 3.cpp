#include <iostream>

using namespace std;

// 1. Функция, которая принимает 2 указателя (на начало и "за конец" массива)
// и возвращает сумму всех элементов в этом диапазоне [begin, end)
int sum_between(const int* begin, const int* end)
{
    int sum = 0;              // переменная для накопления суммы
    const int* p = begin;     // создаём копию указателя begin, чтобы не изменять оригинал
                              // const int* означает, что через этот указатель нельзя менять значения

    while (p != end)          // цикл продолжается, пока указатель p не достигнет end
    {
        sum += *p;            // *p - разыменование указателя (получаем значение по адресу p)
                              // и добавляем его к сумме
        ++p;                  // перемещаем указатель на следующий элемент массива
                              // (увеличиваем адрес на sizeof(int) байт)
    }

    return sum;
}

// 3. Две функции, возвращающие сумму и разность двух целых чисел
int add(int a, int b)
{
    return a + b;
}

int sub(int a, int b)
{
    return a - b;
}

// 4–5. Функция, принимающая char и возвращающая указатель на функцию
//      сложения или вычитания
// using OperationPtr = int(*)(int, int);
// Это псевдоним типа: указатель на функцию, которая принимает 2 int и возвращает int
// int(*)(int, int) - синтаксис указателя на функцию:
//   int - возвращаемый тип
//   (*) - указатель на функцию
//   (int, int) - параметры функции
using OperationPtr = int(*)(int, int);

OperationPtr choose_operation(char op)
{
    if (op == '+')
        return &add;          // &add - берём адрес функции add (получаем указатель на неё)
    if (op == '-')
        return &sub;          // &sub - берём адрес функции sub

    return nullptr;           // nullptr - специальное значение "пустой указатель"
                              // если символ не '+' и не '-'
}

int main()
{
    // 1. Создайте переменную со значением на Ваше усмотрение.
    int value = 10;
    cout << "1) Исходное значение переменной value: " << value << endl;

    // 2. Объявите указатель на созданную переменную.
    int* pValue = &value;     // &value - оператор взятия адреса переменной value
                              // int* - тип "указатель на int"
                              // pValue теперь хранит адрес переменной value в памяти

    // 3. Выведите в консоль адрес указателя и значение, которое хранится по этому адресу.
    cout << "2-3) Адрес, хранящийся в pValue: " << pValue << endl;
                              // pValue без * выводит сам адрес (шестнадцатеричное число)
    cout << "     Значение по адресу pValue (*pValue): " << *pValue << endl;
                              // *pValue - разыменование указателя (получаем значение по адресу)

    // 4. Измените значение, которое хранится по адресу указателя.
    *pValue = 25;             // *pValue = разыменование + присваивание
                              // изменяем значение по адресу, на который указывает pValue
                              // это изменит и переменную value, т.к. pValue указывает на неё

    // 5. Убедитесь, что переменная из 1-го пункта так же изменила своё значение.
    cout << "4-5) Новое значение по адресу pValue: " << *pValue << endl;
    cout << "     Новое значение переменной value: " << value << endl;

    // 6. Создайте массив из нескольких элементов (тип и значение на Ваше усмотрение).
    int arr[5] = { 2, 4, 6, 8, 10 };

    // 7. Выведите все элементы массива в консоль, используя указатель.
    cout << "6-7) Элементы массива через указатель: ";
    int* pArr = arr;          // имя массива arr автоматически преобразуется в указатель
                              // на первый элемент (эквивалентно &arr[0])
    for (int i = 0; i < 5; ++i)
    {
        cout << *(pArr + i) << " ";
                              // pArr + i - арифметика указателей: сдвигаем указатель на i элементов
                              // *(pArr + i) - разыменование: получаем значение элемента
                              // это эквивалентно arr[i] или pArr[i]
    }
    cout << endl;

    // 8. Объявите целую переменную со значением 5.
    int number = 5;
    cout << "8) Исходное значение переменной number: " << number << endl;

    // 9. Создайте такой указатель на эту переменную, чтобы нельзя было менять адрес,
    //    на который он ссылается, но при этом, чтобы через него можно было менять значение.
    int* const pNumber = &number; // int* const - константный указатель
                                  // const относится к самому указателю, а не к значению
                                  // это значит: адрес pNumber нельзя изменить, но значение *pNumber можно

    // Можно менять значение через указатель:
    *pNumber = 15;

    // 10. Убедитесь, что всё сделано правильно:
    // Попытка изменить адрес (раскомментируйте строку ниже -> будет ошибка компиляции):
    // int other = 100;
    // pNumber = &other; // ОШИБКА: присваивание к read-only переменной 'pNumber'

    // А значение через указатель успешно изменилось:
    cout << "9-10) Новое значение через pNumber (*pNumber): " << *pNumber << endl;
    cout << "       Новое значение переменной number: " << number << endl;


    // --- ЗАДАНИЯ 11–18 (вторая часть) ---

    // 11–12. Проверяем функцию sum_between на массиве целых чисел
    int data[6] = { 1, 3, 5, 7, 9, 11 };
    int total = sum_between(data, data + 6); // data - указатель на первый элемент
                                             // data + 6 - указатель на элемент "за последним"
                                             // (это стандартный подход в C++: [begin, end))
                                             // арифметика указателей: data + 6 сдвигает на 6 элементов
    cout << "\nЗадания 11-18:" << endl;
    cout << "11-12) Сумма элементов массива {1, 3, 5, 7, 9, 11} = " << total << endl;

    // 13–16. Работа с функциями суммы, разности и указателем на функцию
    int x = 20;
    int y = 7;

    char opChar = '+'; // поменяйте на '-' для проверки разности
    OperationPtr opPtr = choose_operation(opChar);
                              // opPtr теперь содержит указатель на функцию add или sub

    if (opPtr != nullptr)    // проверяем, что указатель не пустой (функция была найдена)
    {
        int result = opPtr(x, y); // вызов функции через указатель
                                  // opPtr(x, y) эквивалентно (*opPtr)(x, y)
                                  // компилятор автоматически разыменовывает указатель на функцию
        cout << "13-16) Операция '" << opChar << "' над " << x << " и " << y
             << " даёт результат: " << result << endl;
    }
    else
    {
        cout << "13-16) Некорректный символ операции: '" << opChar << "'" << endl;
    }

    // 17–18. Создаём динамический указатель типа float, выводим и удаляем
    float* pFloat = new float(3.14f); // new - оператор динамического выделения памяти
                                      // new float(3.14f) выделяет память для одного float
                                      // и инициализирует его значением 3.14f
                                      // возвращает указатель на выделенную память
    cout << "17-18) Динамический float по адресу " << pFloat
         << " имеет значение: " << *pFloat << endl;

    delete pFloat;      // delete - освобождаем память, выделенную через new
                        // важно: каждый new должен иметь соответствующий delete
    pFloat = nullptr;   // nullptr - обнуляем указатель для безопасности
                        // это предотвращает случайное использование "висячего" указателя

    return 0;
}

